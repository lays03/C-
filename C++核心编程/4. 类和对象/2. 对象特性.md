# 4.2 对象的初始化和清理

## 4.2.1 构造函数和析构函数
对象的初始化和清理也是两个非常重要的安全问题<br>
一个对象或者变量没有初始状态，对其使用后果是未知<br>
同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题<br>

C++利用构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造函数和析构函数，编译器会提供<br>
**编译器提供的构造函数和析构函数是空实现**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
- 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作

构造函数语法：类名(){}
1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次

析构函数语法：~类名(){}
1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次
```cpp
//对象的初始化和清理
//1、构造函数 进行初始化操作
class Person{
public:
    //1、构造函数
    Person(){
        cout << "Person 构造函数的调用" << endl;
    }
    //2、析构函数 进行清理的操作、
    ~Person(){
        cout << "Person 析构函数的调用" << endl;
    }
};

//构造和析构都是必须有的视线，如果我们自己不提供，编译器会提供一个空实现的构造和析构
void test01(){
    Person p;//在栈上的数据，test01执行完毕后，释放这个对象
}

int main(){
    // test01();
    Person p;

    return 0;
}
```

## 4.2.2 构造函数的分类及调用
两种分类方式：<br>
- 按参数分为：有参构造和无参构造
- 按类型分为：普通构造和拷贝构造

三种调用方式：<br>
- 括号法
- 显示法
- 隐式转换法

```cpp
/*
两种分类方式：<br>
- 按参数分为：有参构造和无参构造
- 按类型分为：普通构造和拷贝构造
*/
class Person
{
private:
    /* data */

public:
    int age;
    //构造函数
    Person() //无参构造（默认构造）
    {
        cout << "Person的无参构造函数调用" << endl;
    }
    Person(int a)
    {
        age = a;
        cout << "Person的有参构造函数调用" << endl;
    }
    //拷贝构造函数 
    //因为需要拷贝传进来的数据，因此改数据不能更改，因此加上const，并以引用的方式
    Person(const Person &p){
        //将传入的人身上的属性，拷贝到我身上
        age = p.age;
        cout << "Person的拷贝构造函数调用" << endl;
    }

    ~Person()
    {
        cout << "Person的析构函数调用" << endl;
    }
};

//调用
void test01(){
    //1、括号法
    // Person p1; //默认构造函数调用
    // Person p2(10);
    // Person p3(p2);
    // // cout << "p1的年龄为：" << p1.age << endl;
    // // cout << "p2的年龄为：" << p2.age << endl;
    // // cout << "p2的年龄为：" << p3.age << endl;
    // //注意事项
    // //调用默认构造函数时候，不要加()
    // Person P(); //不会调用构造函数，因为编译器会认为是一个函数的声明
    
    //2、显示法
    // Person p1;
    // Person p2 = Person(10); //有参构造
    // //拷贝构造函数
    // Person p3 = Person(p2);
    // //等号的右边 Person(10); 被叫做“匿名对象”，
    // //特点：当前行执行结束后，系统会立即回收掉匿名对象
    // Person(10); //匿名对象
    // cout << "aaa" << endl;
/*
可以看到，Person(10)调用的是有参构造函数，并且执行完这一行之后，立马调用析构函数
Person的无参构造函数调用
Person的有参构造函数调用
Person的拷贝构造函数调用
Person的有参构造函数调用
Person的析构函数调用
aaa
Person的析构函数调用
Person的析构函数调用
Person的析构函数调用
*/
    //注意事项
    //不要利用拷贝构造函数 初始化匿名对象
    // Person(p3); 错误，编译器会认为Person(p3) === Person p3，会导致p3重定义

    //3、隐式转换法
    Person p4 = 10; //相当于Person p4 = Person(10);
    Person p5 = p4; //隐式转换法的拷贝构造函数调用
}

int main(){
    test01();
}
```